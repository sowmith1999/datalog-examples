#lang racket

; yee another empty file
(require print-debug/print-dbg)
(define to-save-path "/home/sowmith/projects/datalog-examples/slog-examples/brouhaha/input/")
(define rules-path "/home/sowmith/projects/datalog-examples/slog-examples/brouhaha/src/rules.slog")

(define input-list
  '(
(store (f-addr [] "+") (define-prim "+" (varparam "lst")))
	(prim-count "+" [1 2 3 ])
(store (f-addr [] "-") (define-prim "-" (varparam "lst")))
	(prim-count "-" [1 2 3 ])
(store (f-addr [] "*") (define-prim "*" (varparam "lst")))
	(prim-count "*" [1 2 3 ])
(store (f-addr [] "/") (define-prim "/" (varparam "lst")))
	(prim-count "/" [1 2 3 ])
(store (f-addr [] "=") (define-prim "=" (varparam "lst")))
	(prim-count "=" [1 2 3 ])
(store (f-addr [] ">") (define-prim ">" (varparam "lst")))
	(prim-count ">" [1 2 3 ])
(store (f-addr [] "<") (define-prim "<" (varparam "lst")))
	(prim-count "<" [1 2 3 ])
(store (f-addr [] "<=") (define-prim "<=" (varparam "lst")))
	(prim-count "<=" [1 2 3 ])
(store (f-addr [] ">=") (define-prim ">=" (varparam "lst")))
	(prim-count ">=" [1 2 3 ])
(store (f-addr [] "modulo") (define-prim "modulo" (varparam "lst")))
	(prim-count "modulo" [2 ])
(store (f-addr [] "null?") (define-prim "null?" (varparam "lst")))
	(prim-count "null?" [1 ])
(store (f-addr [] "equal?") (define-prim "equal?" (varparam "lst")))
	(prim-count "equal?" [2 ])
(store (f-addr [] "eq?") (define-prim "eq?" (varparam "lst")))
	(prim-count "eq?" [2 ])
(store (f-addr [] "cons") (define-prim "cons" (varparam "lst")))
	(prim-count "cons" [2 ])
(store (f-addr [] "car") (define-prim "car" (varparam "lst")))
	(prim-count "car" [1 ])
(store (f-addr [] "cdr") (define-prim "cdr" (varparam "lst")))
	(prim-count "cdr" [1 ])
(store (f-addr [] "float->int") (define-prim "float->int" (varparam "lst")))
	(prim-count "float->int" [1 ])
(store (f-addr [] "int->float") (define-prim "int->float" (varparam "lst")))
	(prim-count "int->float" [1 ])
(store (f-addr [] "hash") (define-prim "hash" (varparam "lst")))
	(prim-count "hash" [])
(store (f-addr [] "hash-ref") (define-prim "hash-ref" (varparam "lst")))
	(prim-count "hash-ref" [2 ])
(store (f-addr [] "hash-set") (define-prim "hash-set" (varparam "lst")))
	(prim-count "hash-set" [3 ])
(store (f-addr [] "hash-keys") (define-prim "hash-keys" (varparam "lst")))
	(prim-count "hash-keys" [1 ])
(store (f-addr [] "hash-has-key?") (define-prim "hash-has-key?" (varparam "lst")))
	(prim-count "hash-has-key?" [2 ])
(store (f-addr [] "hash-count") (define-prim "hash-count" (varparam "lst")))
	(prim-count "hash-count" [1 ])
(store (f-addr [] "set") (define-prim "set" (varparam "lst")))
	(prim-count "set" [])
(store (f-addr [] "set->list") (define-prim "set->list" (varparam "lst")))
	(prim-count "set->list" [1 ])
(store (f-addr [] "list->set") (define-prim "list->set" (varparam "lst")))
	(prim-count "list->set" [1 ])
(store (f-addr [] "set-add") (define-prim "set-add" (varparam "lst")))
	(prim-count "set-add" [2 ])
(store (f-addr [] "set-member?") (define-prim "set-member?" (varparam "lst")))
	(prim-count "set-member?" [2 ])
(store (f-addr [] "set-remove") (define-prim "set-remove" (varparam "lst")))
	(prim-count "set-remove" [2 ])
(store (f-addr [] "set-count") (define-prim "set-count" (varparam "lst")))
	(prim-count "set-count" [1 ])
(store (f-addr [] "string?") (define-prim "string?" (varparam "lst")))
	(prim-count "string?" [1 ])
(store (f-addr [] "string-length") (define-prim "string-length" (varparam "lst")))
	(prim-count "string-length" [1 ])
(store (f-addr [] "string-ref") (define-prim "string-ref" (varparam "lst")))
	(prim-count "string-ref" [2 ])
(store (f-addr [] "substring") (define-prim "substring" (varparam "lst")))
	(prim-count "substring" [3 ])
(store (f-addr [] "string-append") (define-prim "string-append" (varparam "lst")))
	(prim-count "string-append" [2 ])
(store (f-addr [] "string->list") (define-prim "string->list" (varparam "lst")))
	(prim-count "string->list" [1 ])
(store (f-addr [] "exact-floor") (define-prim "exact-floor" (varparam "lst")))
	(prim-count "exact-floor" [1 ])
(store (f-addr [] "exact-ceiling") (define-prim "exact-ceiling" (varparam "lst")))
	(prim-count "exact-ceiling" [1 ])
(store (f-addr [] "exact-round") (define-prim "exact-round" (varparam "lst")))
	(prim-count "exact-round" [1 ])
(store (f-addr [] "abs") (define-prim "abs" (varparam "lst")))
	(prim-count "abs" [1 ])
(store (f-addr [] "max") (define-prim "max" (varparam "lst")))
	(prim-count "max" [1 ])
(store (f-addr [] "min") (define-prim "min" (varparam "lst")))
	(prim-count "min" [1 ])
(store (f-addr [] "expt") (define-prim "expt" (varparam "lst")))
	(prim-count "expt" [2 ])
(store (f-addr [] "sqrt") (define-prim "sqrt" (varparam "lst")))
	(prim-count "sqrt" [1 ])
(store (f-addr [] "remainder") (define-prim "remainder" (varparam "lst")))
	(prim-count "remainder" [2 ])
(store (f-addr [] "quotient") (define-prim "quotient" (varparam "lst")))
	(prim-count "quotient" [2 ])
(store (f-addr [] "random") (define-prim "random" (varparam "lst")))
	(prim-count "random" [1 2 ])
(store (f-addr [] "symbol?") (define-prim "symbol?" (varparam "lst")))
	(prim-count "symbol?" [1 ])
(store (f-addr [] "pair?") (define-prim "pair?" (varparam "lst")))
	(prim-count "pair?" [1 ])
(store (f-addr [] "positive?") (define-prim "positive?" (varparam "lst")))
	(prim-count "positive?" [1 ])
(store (f-addr [] "negative?") (define-prim "negative?" (varparam "lst")))
	(prim-count "negative?" [1 ])
(store (f-addr [] "list") (define-prim "list" (varparam "lst")))
	(prim-count "list" [1 2 3 4 ])
(store (f-addr [] "list-ref") (define "list-ref" (fixedparam ["lst" "n" ]) (if (app (ref "=") [(int "0")(ref "n")]) (app (ref "car") [(ref "lst")]) (app (ref "list-ref") [(app (ref "cdr") [(ref "lst")])(app (ref "-") [(ref "n")(int "1")])]))))
(store (f-addr [] "member") (define "member" (fixedparam ["item" "lst" ]) (if (if (app (ref "null?") [(ref "item")]) (app (ref "null?") [(ref "item")]) (app (ref "null?") [(ref "lst")])) (bool "f") (if (app (ref "equal?") [(ref "item")(app (ref "car") [(ref "lst")])]) (ref "lst") (app (ref "member") [(ref "item")(app (ref "cdr") [(ref "lst")])])))))
(store (f-addr [] "map") (define "map" (fixedparam ["proc" "lst" ]) (if (app (ref "null?") [(ref "lst")]) (app (ref "list") []) (app (ref "cons") [(app (ref "proc") [(app (ref "car") [(ref "lst")])])(app (ref "map") [(ref "proc")(app (ref "cdr") [(ref "lst")])])]))))
(store (f-addr [] "filter") (define "filter" (fixedparam ["op" "lst" ]) (if (app (ref "null?") [(ref "lst")]) (app (ref "list") []) (if (app (ref "op") [(app (ref "car") [(ref "lst")])]) (app (ref "cons") [(app (ref "car") [(ref "lst")])(app (ref "filter") [(ref "op")(app (ref "cdr") [(ref "lst")])])]) (app (ref "filter") [(ref "op")(app (ref "cdr") [(ref "lst")])])))))
(store (f-addr [] "foldr") (define "foldr" (fixedparam ["fun" "acc" "lst" ]) (if (app (ref "null?") [(ref "lst")]) (ref "acc") (app (ref "fun") [(app (ref "car") [(ref "lst")])(app (ref "foldr") [(ref "fun")(ref "acc")(app (ref "cdr") [(ref "lst")])])]))))
(store (f-addr [] "append1") (define "append1" (fixedparam ["lhs" "rhs" ]) (if (app (ref "null?") [(ref "lhs")]) (ref "rhs") (app (ref "cons") [(app (ref "car") [(ref "lhs")])(app (ref "append1") [(app (ref "cdr") [(ref "lhs")])(ref "rhs")])]))))
(store (f-addr [] "append") (define "append" (varparam "vargs") (let [ (binding "l1" (app (ref "car") [(ref "vargs")])) (binding "vargs8779" (app (ref "cdr") [(ref "vargs")]))] (let [ (binding "l2" (app (ref "car") [(ref "vargs8779")])) (binding "vargs8780" (app (ref "cdr") [(ref "vargs8779")]))] (let [ (binding "lsts" (ref "vargs8780"))] (if (app (ref "null?") [(ref "lsts")]) (app (ref "append1") [(ref "l1")(ref "l2")]) (app (ref "foldr") [(ref "append1")(app (ref "list") [])(app (ref "append1") [(app (ref "list") [(ref "l1")(ref "l2")])(ref "lsts")])])))))))
(store (f-addr [] "list-set") (define "list-set" (fixedparam ["lst" "index" "value" ]) (if (app (ref "=") [(ref "index")(int "0")]) (app (ref "cons") [(ref "value")(app (ref "cdr") [(ref "lst")])]) (app (ref "cons") [(app (ref "car") [(ref "lst")])(app (ref "list-set") [(app (ref "cdr") [(ref "lst")])(app (ref "-") [(ref "index")(int "1")])(ref "value")])]))))
(store (f-addr [] "flatten") (define "flatten" (fixedparam ["lst" ]) (if (app (ref "null?") [(ref "lst")]) (app (ref "list") []) (if (app (ref "pair?") [(ref "lst")]) (app (ref "append") [(app (ref "flatten") [(app (ref "car") [(ref "lst")])])(app (ref "flatten") [(app (ref "cdr") [(ref "lst")])])]) (app (ref "list") [(ref "lst")])))))
(store (f-addr [] "ack") (define "ack" (fixedparam ["m" "n" ]) (if (app (ref "=") [(ref "m")(int "0")]) (app (ref "+") [(ref "n")(int "1")]) (if (app (ref "=") [(ref "n")(int "0")]) (app (ref "ack") [(app (ref "-") [(ref "m")(int "1")])(int "1")]) (app (ref "ack") [(app (ref "-") [(ref "m")(int "1")])(app (ref "ack") [(ref "m")(app (ref "-") [(ref "n")(int "1")])])])))))
(store (f-addr [] "brouhaha_main") (define "brouhaha_main" (fixedparam []) (app (ref "ack") [(int "3")(int "12")])))
    ))

;; There can be three things in the fact
;; 1) another nested fact
;; 2) some element
;; 3) A slog list - This can also have all the above

(define (relmap-update new-fact fact-type rel_map)
  (hash-set rel_map fact-type (cons new-fact (hash-ref rel_map fact-type '()))))

(define (process-items items rel_map)
  (foldl
   (lambda (item acc)
     (match item
       [(? string? val)
        `(,(append (car acc) `("datum" ,val)) ,(cadr acc))]
       [(? number? val)
        `(,(append (car acc) `("datum" ,val)) ,(cadr acc))]
       [`(,(? symbol? rel-name) ,items ...)
        (match-define (list id fact-type updated-relmap) (gen-process `(,rel-name ,@items) (cadr acc)))
        `(,(append (car acc) `(,fact-type ,id)) ,updated-relmap)]
       [`,(? list? slog-lst)
        #:when (andmap (lambda (val) (or (string? val) (number? val) (list? val))) slog-lst)
        (match-define (list id fact-type updated-relmap) (gen-process `("slog-lst" ,slog-lst) (cadr acc)))
        `(,(append (car acc) `(,fact-type ,id)) ,updated-relmap)]
       ))
   `(() ,rel_map) items))

(define (gen-process fact [rel_map (hash)])
  (match fact
    [`(,(? symbol? rel-name) ,items ...)
     (define fact-type (string-append "flat-" (symbol->string rel-name)))
     (define id (gensym ""))
     (match-define (list new-flat-fact new-rel-map) (process-items items rel_map))
     (define updated-relmap (relmap-update `(,id ,@new-flat-fact) fact-type new-rel-map))
     `(,id ,fact-type ,updated-relmap)
     ]
    [`("slog-lst" ,items)
     (define fact-type (string-append "flat-list-" (number->string (length items))))
     (define id (gensym ""))
     (match-define (list new-flat-fact new-rel-map) (process-items items rel_map))
     (define updated-relmap (relmap-update `(,id ,@new-flat-fact) fact-type new-rel-map))
     `(,id ,fact-type ,updated-relmap)]
    )
  )

(define (write-to-file rel_name rel_map)
  (define file-path (string-append to-save-path rel_name ".csv"))
  (define (str-correct item)
    (match item
        [(? string? val)
         (string-append "\"" val "\"")]
        [(? symbol? val)
         (symbol->string val)]
        [(? number? val)
         (number->string val)]))
  (define (lines-to-write list-of-facts)
    (string-join (map (lambda (fact) (string-join (map str-correct fact) "\t")) list-of-facts) "\n"))
  (define file-out (open-output-file file-path #:exists 'replace))
  (fprintf file-out "~a" (lines-to-write (hash-ref rel_map rel_name '()))))

(define (write-relation rel_map)
  (foldl (lambda (rel acc) (write-to-file rel rel_map)) '() (hash-keys rel_map)))


(define (write-a-rule is-list item [item-str "("])
  (if (null? item)
    (if is-list (string-append item-str "])") (string-append item-str ")"))
  (match item 
    [`(,(? symbol? rel) ,id ,rst ...)
      #:when (and is-list (= (string-length item-str) 1))
      (write-a-rule is-list (cddr item) (string-append item-str " " (symbol->string rel) " " (symbol->string id) " [")) 
      ]
    [`(,(? symbol? rel) ,rst ...)
      (write-a-rule is-list (cdr item) (string-append item-str (symbol->string rel) " "))
    ]
    [`(,(? string? str) ,rst ...)
      (write-a-rule is-list (cdr item) (string-append item-str " " (string-append "\"" str "\"") " "))
    ]
    [`(,(? list? slog-list) ,rst ...)
      #:when is-list
      (write-a-rule is-list slog-list item-str)
    ]
    [`(,(? list? sub-rel) ,rst ...)
      (define sub-rel-str (write-a-rule #f sub-rel))
      (write-a-rule is-list (cdr item) (string-append item-str sub-rel-str))
    ])))

(define (write-rules rule-set)
  (define file-path rules-path)
  (define file-out (open-output-file file-path #:exists 'replace)) 
    (for ([rule (set->list rule-set)])
      (match rule
        [`((,rel ,rst-head ...) ,body-rules)
          #:when (equal? (substring (symbol->string rel) 0 (min 4 (string-length (symbol->string rel)))) "list")
          (define head-str (write-a-rule #t `(,rel ,@rst-head)))
          (define body-str (string-join (map (lambda (item) (write-a-rule #f item)) body-rules) " "))
          (define rule (string-append "[" body-str " --> " head-str "]\n"))
          (fprintf file-out rule)
        ]
        [`(,head ,body-rules)
          (define head-str (write-a-rule #f head))
          (define body-str (string-join (map (lambda (item) (write-a-rule #f item)) body-rules) " "))
          (define rule (string-append "[" body-str " --> " head-str "]\n"))
          (fprintf file-out rule)
         ])))

(define (process-list-of-facts input-list [rel_map (hash)])
  (foldl (lambda (fact acc) (caddr (gen-process fact acc)))
         rel_map input-list))

(define (make-main-body-rel rel_name fact arity [head `()] [body `()])
  (define (str-sym . vals)
    (string->symbol (apply string-append vals)))
  (define num->str number->string)
  (define str->sym string->symbol)
  (match fact
    [`(,(? symbol? id) ,rst ...)
     (define main-body-rule `(,(str->sym rel_name) id))
     (define rel_og (substring rel_name 5 (string-length rel_name)))
     ;; (displayln `(,rel_name ,rel_og))
     (define head-rule 
     (if (equal? (substring rel_og 0 (min 4 (string-length rel_og))) "list")
       `(,(str-sym rel_og "-holder") id ())
       `(,(str-sym rel_og "-holder") id (,(str->sym rel_og)))))
     (p-dbg (make-main-body-rel rel_name (cdr fact) arity (p-dbg head-rule) (cons main-body-rule body)))
     ]
    [`("datum" ,val ,rst ...)
     (define val-sym (p-dbg (str->sym (string-append "datum" (num->str arity) "-val"))))
     (define updated-main-body (p-dbg (append (car body) `("datum" ,val-sym))))
     (define updated-body (p-dbg (append `(,updated-main-body) (cdr body))))
     (define updated-head (append (take head 2) `(,(append (caddr head) (list val-sym)))))
     (make-main-body-rel rel_name (cddr fact) (- arity 1) (p-dbg updated-head) (p-dbg updated-body))
     ]
    [`(,(? string? rel_str) ,rel-id ,rst ...)
     (define cur_rel_og (substring rel_str 5 (string-length rel_str)))
     (define rel-sym (str->sym (string-append rel_str "-" (num->str arity) "-id")))
     (define holder-sym (str->sym (string-append cur_rel_og "-holder")))
     (displayln `(,cur_rel_og ,holder-sym))
     (define lifted-sym (str->sym (string-append "lifted-" cur_rel_og "-" (num->str arity) "-fact")))
     (define new-body-item `(,holder-sym ,rel-sym ,lifted-sym))
     (define updated-main-body (append (car body) `(,rel_str ,rel-sym)))
     (define updated-body (append (list updated-main-body) (append (cdr body) (list new-body-item))))
     (define updated-head (append (take head 2) `(,(append (caddr head) (list lifted-sym)))))
     (make-main-body-rel rel_name (cddr fact) (- arity 1) (p-dbg updated-head) (p-dbg updated-body))
     ]
    [`()
     `(,head ,body)]
    )
  )

(define (lifting-rules rel_map)
  (define (lifting-rules-for-* is-list fact-list rel_name [rule-set (set)])
    (if (null? fact-list)
        rule-set
        (let*
            ((fact (car fact-list))
             (arity (/ (- (length fact) 1) 2))
             (rule (if is-list (make-main-body-rel rel_name fact arity)
                       (make-main-body-rel rel_name fact arity))))
          (lifting-rules-for-* is-list (cdr fact-list) rel_name (set-add rule-set rule)))))
  (foldl (lambda (rel_name acc)
           (let* ([rel_type (p-dbg (substring rel_name 0 (min 9 (string-length rel_name))))]
                  [fact-list (hash-ref rel_map rel_name)]
                  [is-list (if (p-dbg (equal? rel_type "flat-list")) #t #f)])
             (set-union acc (lifting-rules-for-* is-list fact-list rel_name))))
         (set) (hash-keys rel_map)))

(define test-input-list
  '((app (ref "=") [(int "0")(ref "n") "1"])))

(define rel_map (process-list-of-facts input-list))
;; (define rel_map (process-list-of-facts input-list))
(pretty-print rel_map)
;; (write-relation rel_map)
;; (pretty-print (set-count (lifting-rules rel_map)))
(define rule-set (lifting-rules rel_map))
;; (write-rules rule-set)
(pretty-print rule-set)
(write-rules rule-set)
