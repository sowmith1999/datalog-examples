(store (f-addr [] "+") (define-prim "+" (varparam "lst")))
	(prim-count "+" [1 2 3 ])
(store (f-addr [] "-") (define-prim "-" (varparam "lst")))
	(prim-count "-" [1 2 3 ])
(store (f-addr [] "*") (define-prim "*" (varparam "lst")))
	(prim-count "*" [1 2 3 ])
(store (f-addr [] "/") (define-prim "/" (varparam "lst")))
	(prim-count "/" [1 2 3 ])
(store (f-addr [] "=") (define-prim "=" (varparam "lst")))
	(prim-count "=" [1 2 3 ])
(store (f-addr [] ">") (define-prim ">" (varparam "lst")))
	(prim-count ">" [1 2 3 ])
(store (f-addr [] "<") (define-prim "<" (varparam "lst")))
	(prim-count "<" [1 2 3 ])
(store (f-addr [] "<=") (define-prim "<=" (varparam "lst")))
	(prim-count "<=" [1 2 3 ])
(store (f-addr [] ">=") (define-prim ">=" (varparam "lst")))
	(prim-count ">=" [1 2 3 ])
(store (f-addr [] "modulo") (define-prim "modulo" (varparam "lst")))
	(prim-count "modulo" [2 ])
(store (f-addr [] "null?") (define-prim "null?" (varparam "lst")))
	(prim-count "null?" [1 ])
(store (f-addr [] "equal?") (define-prim "equal?" (varparam "lst")))
	(prim-count "equal?" [2 ])
(store (f-addr [] "eq?") (define-prim "eq?" (varparam "lst")))
	(prim-count "eq?" [2 ])
(store (f-addr [] "cons") (define-prim "cons" (varparam "lst")))
	(prim-count "cons" [2 ])
(store (f-addr [] "car") (define-prim "car" (varparam "lst")))
	(prim-count "car" [1 ])
(store (f-addr [] "cdr") (define-prim "cdr" (varparam "lst")))
	(prim-count "cdr" [1 ])
(store (f-addr [] "float->int") (define-prim "float->int" (varparam "lst")))
	(prim-count "float->int" [1 ])
(store (f-addr [] "int->float") (define-prim "int->float" (varparam "lst")))
	(prim-count "int->float" [1 ])
(store (f-addr [] "hash") (define-prim "hash" (varparam "lst")))
	(prim-count "hash" [])
(store (f-addr [] "hash-ref") (define-prim "hash-ref" (varparam "lst")))
	(prim-count "hash-ref" [2 ])
(store (f-addr [] "hash-set") (define-prim "hash-set" (varparam "lst")))
	(prim-count "hash-set" [3 ])
(store (f-addr [] "hash-keys") (define-prim "hash-keys" (varparam "lst")))
	(prim-count "hash-keys" [1 ])
(store (f-addr [] "hash-has-key?") (define-prim "hash-has-key?" (varparam "lst")))
	(prim-count "hash-has-key?" [2 ])
(store (f-addr [] "hash-count") (define-prim "hash-count" (varparam "lst")))
	(prim-count "hash-count" [1 ])
(store (f-addr [] "set") (define-prim "set" (varparam "lst")))
	(prim-count "set" [])
(store (f-addr [] "set->list") (define-prim "set->list" (varparam "lst")))
	(prim-count "set->list" [1 ])
(store (f-addr [] "list->set") (define-prim "list->set" (varparam "lst")))
	(prim-count "list->set" [1 ])
(store (f-addr [] "set-add") (define-prim "set-add" (varparam "lst")))
	(prim-count "set-add" [2 ])
(store (f-addr [] "set-member?") (define-prim "set-member?" (varparam "lst")))
	(prim-count "set-member?" [2 ])
(store (f-addr [] "set-remove") (define-prim "set-remove" (varparam "lst")))
	(prim-count "set-remove" [2 ])
(store (f-addr [] "set-count") (define-prim "set-count" (varparam "lst")))
	(prim-count "set-count" [1 ])
(store (f-addr [] "string?") (define-prim "string?" (varparam "lst")))
	(prim-count "string?" [1 ])
(store (f-addr [] "string-length") (define-prim "string-length" (varparam "lst")))
	(prim-count "string-length" [1 ])
(store (f-addr [] "string-ref") (define-prim "string-ref" (varparam "lst")))
	(prim-count "string-ref" [2 ])
(store (f-addr [] "substring") (define-prim "substring" (varparam "lst")))
	(prim-count "substring" [3 ])
(store (f-addr [] "string-append") (define-prim "string-append" (varparam "lst")))
	(prim-count "string-append" [2 ])
(store (f-addr [] "string->list") (define-prim "string->list" (varparam "lst")))
	(prim-count "string->list" [1 ])
(store (f-addr [] "exact-floor") (define-prim "exact-floor" (varparam "lst")))
	(prim-count "exact-floor" [1 ])
(store (f-addr [] "exact-ceiling") (define-prim "exact-ceiling" (varparam "lst")))
	(prim-count "exact-ceiling" [1 ])
(store (f-addr [] "exact-round") (define-prim "exact-round" (varparam "lst")))
	(prim-count "exact-round" [1 ])
(store (f-addr [] "abs") (define-prim "abs" (varparam "lst")))
	(prim-count "abs" [1 ])
(store (f-addr [] "max") (define-prim "max" (varparam "lst")))
	(prim-count "max" [1 ])
(store (f-addr [] "min") (define-prim "min" (varparam "lst")))
	(prim-count "min" [1 ])
(store (f-addr [] "expt") (define-prim "expt" (varparam "lst")))
	(prim-count "expt" [2 ])
(store (f-addr [] "sqrt") (define-prim "sqrt" (varparam "lst")))
	(prim-count "sqrt" [1 ])
(store (f-addr [] "remainder") (define-prim "remainder" (varparam "lst")))
	(prim-count "remainder" [2 ])
(store (f-addr [] "quotient") (define-prim "quotient" (varparam "lst")))
	(prim-count "quotient" [2 ])
(store (f-addr [] "random") (define-prim "random" (varparam "lst")))
	(prim-count "random" [1 2 ])
(store (f-addr [] "symbol?") (define-prim "symbol?" (varparam "lst")))
	(prim-count "symbol?" [1 ])
(store (f-addr [] "pair?") (define-prim "pair?" (varparam "lst")))
	(prim-count "pair?" [1 ])
(store (f-addr [] "positive?") (define-prim "positive?" (varparam "lst")))
	(prim-count "positive?" [1 ])
(store (f-addr [] "negative?") (define-prim "negative?" (varparam "lst")))
	(prim-count "negative?" [1 ])
(store (f-addr [] "list") (define-prim "list" (varparam "lst")))
	(prim-count "list" [1 2 3 4 ])
(store (f-addr [] "list-ref") (define "list-ref" (fixedparam ["lst" "n" ]) (if (app (ref "=") [(int "0")(ref "n")]) (app (ref "car") [(ref "lst")]) (app (ref "list-ref") [(app (ref "cdr") [(ref "lst")])(app (ref "-") [(ref "n")(int "1")])]))))
(store (f-addr [] "member") (define "member" (fixedparam ["item" "lst" ]) (if (if (app (ref "null?") [(ref "item")]) (app (ref "null?") [(ref "item")]) (app (ref "null?") [(ref "lst")])) (bool "f") (if (app (ref "equal?") [(ref "item")(app (ref "car") [(ref "lst")])]) (ref "lst") (app (ref "member") [(ref "item")(app (ref "cdr") [(ref "lst")])])))))
(store (f-addr [] "map") (define "map" (fixedparam ["proc" "lst" ]) (if (app (ref "null?") [(ref "lst")]) (app (ref "list") []) (app (ref "cons") [(app (ref "proc") [(app (ref "car") [(ref "lst")])])(app (ref "map") [(ref "proc")(app (ref "cdr") [(ref "lst")])])]))))
(store (f-addr [] "filter") (define "filter" (fixedparam ["op" "lst" ]) (if (app (ref "null?") [(ref "lst")]) (app (ref "list") []) (if (app (ref "op") [(app (ref "car") [(ref "lst")])]) (app (ref "cons") [(app (ref "car") [(ref "lst")])(app (ref "filter") [(ref "op")(app (ref "cdr") [(ref "lst")])])]) (app (ref "filter") [(ref "op")(app (ref "cdr") [(ref "lst")])])))))
(store (f-addr [] "foldr") (define "foldr" (fixedparam ["fun" "acc" "lst" ]) (if (app (ref "null?") [(ref "lst")]) (ref "acc") (app (ref "fun") [(app (ref "car") [(ref "lst")])(app (ref "foldr") [(ref "fun")(ref "acc")(app (ref "cdr") [(ref "lst")])])]))))
(store (f-addr [] "append1") (define "append1" (fixedparam ["lhs" "rhs" ]) (if (app (ref "null?") [(ref "lhs")]) (ref "rhs") (app (ref "cons") [(app (ref "car") [(ref "lhs")])(app (ref "append1") [(app (ref "cdr") [(ref "lhs")])(ref "rhs")])]))))
(store (f-addr [] "append") (define "append" (varparam "vargs") (let [ (binding "l1" (app (ref "car") [(ref "vargs")])) (binding "vargs8779" (app (ref "cdr") [(ref "vargs")]))] (let [ (binding "l2" (app (ref "car") [(ref "vargs8779")])) (binding "vargs8780" (app (ref "cdr") [(ref "vargs8779")]))] (let [ (binding "lsts" (ref "vargs8780"))] (if (app (ref "null?") [(ref "lsts")]) (app (ref "append1") [(ref "l1")(ref "l2")]) (app (ref "foldr") [(ref "append1")(app (ref "list") [])(app (ref "append1") [(app (ref "list") [(ref "l1")(ref "l2")])(ref "lsts")])])))))))
(store (f-addr [] "list-set") (define "list-set" (fixedparam ["lst" "index" "value" ]) (if (app (ref "=") [(ref "index")(int "0")]) (app (ref "cons") [(ref "value")(app (ref "cdr") [(ref "lst")])]) (app (ref "cons") [(app (ref "car") [(ref "lst")])(app (ref "list-set") [(app (ref "cdr") [(ref "lst")])(app (ref "-") [(ref "index")(int "1")])(ref "value")])]))))
(store (f-addr [] "flatten") (define "flatten" (fixedparam ["lst" ]) (if (app (ref "null?") [(ref "lst")]) (app (ref "list") []) (if (app (ref "pair?") [(ref "lst")]) (app (ref "append") [(app (ref "flatten") [(app (ref "car") [(ref "lst")])])(app (ref "flatten") [(app (ref "cdr") [(ref "lst")])])]) (app (ref "list") [(ref "lst")])))))
(store (f-addr [] "ll") (define "ll" (fixedparam []) (app (ref "list") [(app (ref "list") [(int "0")(int "1")(int "2")])(app (ref "list") [(int "3")(int "4")(int "5")])(app (ref "list") [(int "6")(int "7")(int "8")])])))
(store (f-addr [] "get-element") (define "get-element" (fixedparam ["brd" "i" "j" ]) (app (ref "list-ref") [(app (ref "list-ref") [(ref "brd")(ref "i")])(ref "j")])))
(store (f-addr [] "generate-pairs") (define "generate-pairs" (fixedparam ["rr" "cc" ]) (app (ref "foldr") [(lambda (fixedparam ["r""acc"]) (app (ref "append") [(app (ref "map") [(lambda (fixedparam ["c"]) (app (ref "list") [(ref "r")(ref "c")]))(ref "cc")])(ref "acc")]))(app (ref "list") [])(ref "rr")])))
(store (f-addr [] "access-elements") (define "access-elements" (fixedparam ["rr" "cc" "brd" ]) (app (ref "map") [(lambda (fixedparam ["pair"]) (app (ref "get-element") [(ref "brd")(app (ref "car") [(ref "pair")])(app (ref "car") [(app (ref "cdr") [(ref "pair")])])]))(app (ref "generate-pairs") [(ref "rr")(ref "cc")])])))
(store (f-addr [] "subgrid") (define "subgrid" (fixedparam ["brd" "r" "c" ]) (let [ (binding "rr" (app (ref "flatten") [(app (ref "filter") [(lambda (fixedparam ["x"]) (app (ref "member") [(ref "r")(ref "x")]))(app (ref "ll") [])])])) (binding "cc" (app (ref "flatten") [(app (ref "filter") [(lambda (fixedparam ["x"]) (app (ref "member") [(ref "c")(ref "x")]))(app (ref "ll") [])])]))] (app (ref "access-elements") [(ref "rr")(ref "cc")(ref "brd")]))))
(store (f-addr [] "newbd") (define "newbd" (fixedparam ["brd" "r" "c" "i" ]) (app (ref "list-set") [(ref "brd")(ref "r")(app (ref "list-set") [(app (ref "list-ref") [(ref "brd")(ref "r")])(ref "c")(ref "i")])])))
(store (f-addr [] "solve-board") (define "solve-board" (fixedparam ["brd" "r" "c" "lst" "result" ]) (if (app (ref "equal?") [(ref "result")(symbol "solved")]) (ref "result") (if (app (ref "null?") [(ref "lst")]) (ref "result") (if (if (if (app (ref "member") [(app (ref "car") [(ref "lst")])(app (ref "list-ref") [(ref "brd")(ref "r")])]) (bool "f") (bool "t")) (if (if (app (ref "member") [(app (ref "car") [(ref "lst")])(app (ref "map") [(lambda (fixedparam ["x"]) (app (ref "list-ref") [(ref "x")(ref "c")]))(ref "brd")])]) (bool "f") (bool "t")) (if (app (ref "member") [(app (ref "car") [(ref "lst")])(app (ref "subgrid") [(ref "brd")(ref "r")(ref "c")])]) (bool "f") (bool "t")) (bool "f")) (bool "f")) (app (ref "solve-board") [(ref "brd")(ref "r")(ref "c")(app (ref "cdr") [(ref "lst")])(let [ (binding "newbrd" (app (ref "newbd") [(ref "brd")(ref "r")(ref "c")(app (ref "car") [(ref "lst")])]))] (if (app (ref "<") [(app (ref "+") [(int "1")(ref "c")])(int "9")]) (app (ref "SolveSudoku") [(ref "newbrd")(ref "r")(app (ref "+") [(int "1")(ref "c")])]) (if (app (ref "<") [(app (ref "+") [(int "1")(ref "r")])(int "9")]) (app (ref "SolveSudoku") [(ref "newbrd")(app (ref "+") [(int "1")(ref "r")])(int "0")]) (symbol "solved"))))]) (app (ref "solve-board") [(ref "brd")(ref "r")(ref "c")(app (ref "cdr") [(ref "lst")])(ref "result")]))))))
(store (f-addr [] "SolveSudoku") (define "SolveSudoku" (fixedparam ["brd" "r" "c" ]) (if (app (ref "=") [(int "0")(app (ref "list-ref") [(app (ref "list-ref") [(ref "brd")(ref "r")])(ref "c")])]) (app (ref "solve-board") [(ref "brd")(ref "r")(ref "c")(app (ref "list") [(int "1")(int "2")(int "3")(int "4")(int "5")(int "6")(int "7")(int "8")(int "9")])(symbol "unsolved")]) (if (app (ref "<") [(app (ref "+") [(int "1")(ref "c")])(int "9")]) (app (ref "SolveSudoku") [(ref "brd")(ref "r")(app (ref "+") [(int "1")(ref "c")])]) (if (app (ref "<") [(app (ref "+") [(int "1")(ref "r")])(int "9")]) (app (ref "SolveSudoku") [(ref "brd")(app (ref "+") [(int "1")(ref "r")])(int "0")]) (symbol "solved"))))))
(store (f-addr [] "board") (define "board" (fixedparam []) (app (ref "list") [(app (ref "list") [(int "5")(int "3")(int "0")(int "0")(int "7")(int "0")(int "0")(int "0")(int "0")])(app (ref "list") [(int "6")(int "0")(int "0")(int "1")(int "9")(int "5")(int "0")(int "0")(int "0")])(app (ref "list") [(int "0")(int "9")(int "8")(int "0")(int "0")(int "0")(int "0")(int "6")(int "0")])(app (ref "list") [(int "8")(int "0")(int "0")(int "0")(int "6")(int "0")(int "0")(int "0")(int "3")])(app (ref "list") [(int "4")(int "0")(int "0")(int "8")(int "0")(int "3")(int "0")(int "0")(int "1")])(app (ref "list") [(int "7")(int "0")(int "0")(int "0")(int "2")(int "0")(int "0")(int "0")(int "6")])(app (ref "list") [(int "0")(int "6")(int "0")(int "0")(int "0")(int "0")(int "2")(int "8")(int "0")])(app (ref "list") [(int "0")(int "0")(int "0")(int "4")(int "1")(int "9")(int "0")(int "0")(int "5")])(app (ref "list") [(int "0")(int "0")(int "0")(int "0")(int "8")(int "0")(int "0")(int "7")(int "9")])])))
(store (f-addr [] "brouhaha_main") (define "brouhaha_main" (fixedparam []) (app (ref "SolveSudoku") [(app (ref "board") [])(int "0")(int "0")])))


;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;APPENDED PROGRAM ABOVE;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;ANALYSIS PROGRAM BELOW;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;


;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;::;;;;PRIM TAGGING::;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;

;NUMERIC-PRIMS
(numeric-prim "+")
(numeric-prim "-")
(numeric-prim "*")
(numeric-prim "/")
(numeric-prim "=")
(numeric-prim "modulo")


;BOOL-PRIMS
(bool-prim "=")
(bool-prim ">")
(bool-prim "<")
(bool-prim "<=")
(bool-prim ">=")
(bool-prim "null?")
(bool-prim "equal?")
(bool-prim "eq?")




;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;FREE VARIABLES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
;NON-LIST-VALUES
(non-list-value ?(symbol _))
(non-list-value ?(bool _))
(non-list-value ?(int _))
(non-list-value ?(string _))
(non-list-value ?(state _))


; (non-list-value (or (addr _) (quote _) (string _) (bool _) (state _)))

;REF VARIABLES
(free x ?(ref x))

;LAMBDAS
[(free x eb)
 (=/= y x)
 -->
 (free x ?(lambda (varparam y) eb))]

[(free x eb)
 -->
 (do-free-lam ?(lambda (fixedparam ys) eb) ys x)]

[(do-free-lam lam [y ys ...] x)
 (=/= y x)
 -->
 (do-free-lam lam ys x)]

[(do-free-lam lam [] x)
 -->
 (free x lam)]

;APPL
[(or (free x ef) (free x ea))
 -->
 (free x ?(appl ef ea))]

;IF EXPRESSIONS
[(or (free x guard) (free x tExp) (free x fExp))
 -->
 (free x ?(if guard tExp fExp))]

;APP
[(free x ef)
 -->
(free x ?(app ef eas))]

(do-free-app ?(app ef eas) eas)

[(do-free-app app [ea eas ...])
 -->
 (do-free-app app eas)
 [(free x ea)
  -->
  (free x app)]]


;LET BINDINGS RIGHT HAND SIDES
(do-free-let-rhs ?(let binds body) binds)

[(do-free-let-rhs let [bind binds ...])
 -->
(do-free-let-rhs let binds)]    

[(do-free-let-rhs let [(binding lhs rhs) binds ...])
 (free x rhs)
 -->
 (free x let)]

;LET BINDINGS LEFT HAND SIDES
[(free x body)
 -->
(do-free-let-lhs ?(let binds body) binds x)]

[(do-free-let-lhs let [(binding lhs rhs) binds ...] x)
 (=/= lhs x)
 -->
 (do-free-let-lhs let binds x)]

[(do-free-let-lhs let [] x)
 -->
 (free x let)]



;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;START RULE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
[(define "brouhaha_main" (fixedparam []) body)
 -->
 (eval body [] (halt))]

(tick ?(do-tick [] call) [call])
(tick ?(do-tick [x] call) [call x])
(tick ?(do-tick [x y] call) [call x y])
(tick ?(do-tick [x y _] call) [call x y])


;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EVAL CASES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
;BASE PRIMITIVE TYPES
[(eval (symbol val) ctx kont)
 -->
 (store (f-addr ctx (symbol val)) (symbol-val val))
 (ret (f-addr ctx (symbol val)) kont)]

[(eval (bool val) ctx kont)
 -->
 (store (f-addr ctx (bool val)) (bool-val val))
 (ret (f-addr ctx (bool val)) kont)]

[(eval (int val) ctx kont)
 -->
 (store (f-addr ctx (int val)) (int-val val))
 (ret (f-addr ctx (int val)) kont)]

[(eval (string val) ctx kont)
 -->
 (store (f-addr ctx (string val)) (string-val val))
 (ret (f-addr ctx (string val)) kont)]

[(eval (state val) ctx kont)
 -->
 (store (f-addr ctx (state val)) (state-val val))
 (ret (f-addr ctx (state val)) kont)]

;FUNCTION AND VARIABLE REFERENCES
[(eval (ref x) ctx kont)
 -->
 (ret (f-addr ctx x) kont)]

;LAMBDA AND FUNC
[(eval e ctx kont)
 (= e (lambda _ _))
 -->
 (store (f-addr ctx e) (clo e ctx))
 (ret (f-addr ctx e) kont)]
        
;APP AND APPLY
[(eval call ctx kont)
 (= call (app ef [eas ...]))
 -->
 (eval ef ctx (appk call [] eas ctx kont))]

[(eval call ctx kont)
 (= call (appl ef ea))
 -->
 (eval ef ctx (applak call ea ctx kont))]

;IF CASE
[(eval (if guard tExp fExp) ctx kont)
 -->
 (eval guard ctx (if-k tExp fExp ctx kont))]

;LET CASE
[(eval call ctx kont)
 (= call (let [(binding lhs rhs) bind-rest ...] body))
 -->
 (eval rhs ctx (letk call body [lhs] [] bind-rest ctx kont))]

;---------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;RET CASES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;---------------------------------------------------------------------;
;LAMBDA AND FUNC
[(ret a (appk call [as ...] [ea0 ea-rest ...] ctx kont))
 -->
 (eval ea0 ctx (appk call [as ... a] [ea-rest ...] ctx kont))]

[(ret a (appk call [af as ...] [] ctx kont))
 (store af vf)
 -->
 (apply vf (fixedarg [as ... a]) ctx kont call)]

[(ret af (appk call [] [] ctx kont))
 (store af vf)
 -->
 (apply vf (fixedarg []) ctx kont call)]

[(ret af (applak call ea ctx kont))
 -->
 (eval ea ctx (applfk call af ctx kont))]

[(ret a (applfk call af ctx kont))
 (store af vf)
 -->
 (apply vf (vararg a) ctx kont call)]

[(ret a (k-addr eb))
 -->
 (ret a {store (k-addr eb)})]

;IF CASES
[(ret ga (if-k tExp fExp ctx kont))
 (store ga (bool "t"))
 --> 
 (eval tExp ctx kont)]

[(ret ga (if-k tExp fExp ctx kont))
 (store ga (bool "f"))
 --> 
 (eval fExp ctx kont)]

[(ret (s-addr _) (if-k tExp fExp ctx kont))
 --> 
 (eval tExp ctx kont)
 (eval fExp ctx kont)]

;LET CASE
[(ret a (letk call body [xs ...] [as ...] [(binding lhs rhs) bind-rest ...] ctx kont))
 -->
 (eval rhs ctx (letk call body [xs ... lhs] [as ... a] bind-rest ctx kont))]

[(ret a (letk call body [xs ...] [as ...] [] ctxlet kont))
 -->
 (= ctxtick {tick !(do-tick ctxlet call)})
 (store (k-addr body) kont)
 (do-fixed-prop-all ctxlet xs [as ... a])
 (eval body ctxtick (k-addr body))
 
 [(free y body)
  -->
  (store (f-addr ctxtick y) {store (f-addr ctxlet y)})
  ; (store-flow (f-addr ctxtick y) (f-addr ctxlam y))
  ]]




;---------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;APPLY CASES;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;---------------------------------------------------------------------;
;DEFINE --> CLOSURE
[(apply (define fname params body) args ctx kont call)
 --> 
 (apply (clo (lambda params body) []) args ctx kont call)]  

;DEFINE-PRIM HANDLING (NOT SPECIALIZED)
[(apply (define-prim fname _) _ _ kont _)
 (~ specialized-prim fname)
 -->
 (store (s-addr fname) (state fname))
 (ret (s-addr fname) kont)]

;  [(= e (apply (define-prim fname _) args _ kont _))
;  (~ specialized-prim fname)
;  -->
;  (store (s-addr e) (state e))
;  (ret (s-addr e) kont)]


;SPECIALIZED PRIMS
(specialized-prim "cons")
  [(= e (apply (define-prim "cons" _) (fixedarg [a0 a1]) ctx kont _))
  (store a1 (list-of-vals as))
  -->
  (store (f-addr ctx e) (list-of-vals [a0 as ...]))
  (ret (f-addr ctx e) kont)]

  [(= e (apply (define-prim "cons" _) (fixedarg [a0 a1]) ctx kont _))
  (store a1 val)
  (non-list-value val)
  -->
  (store (f-addr ctx e) (list-of-vals [a0 a1]))
  (ret (f-addr ctx e) kont)]

  ;VARIADIC
  [(= e (apply (define-prim "cons" _) (vararg a) ctx kont call))
  (store a (list-of-vals as))
  --> 
  (do-store-addr-union (f-addr ctx e) as [])
  (ret (f-addr ctx e) kont)]

  ;When the next address points to a list-of-vals
  [(do-store-addr-union addr [a as ...] [union-as ...])
  (store a (list-of-vals under-as))
  -->
  (do-store-addr-union addr as [a under-as ... union-as ...])]

  ;When the next address points to a single addr
  [(do-store-addr-union addr [a as ...] [union-as ...])
  (store a val)
  (non-list-value val)
  -->
  (do-store-addr-union addr as [a union-as])]
 
  [(do-store-addr-union addr [] [union-as ...])
  -->
  (store addr (list-of-vals union-as))]


(specialized-prim "null?")
  [(= e (apply (define-prim "null?" _) (fixedarg [a]) ctx kont _))
   (store a (list-of-vals as))
   (= as [])
   -->
   (store (f-addr ctx e) (bool "t"))
   (ret (f-addr ctx e) kont)]

  [(= e (apply (define-prim "null?" _) (fixedarg [a]) ctx kont _))
   (store a (list-of-vals [a0 as ...]))
   -->
   (store (f-addr ctx e) (bool "t"))
   (store (f-addr ctx e) (bool "f"))
   (ret (f-addr ctx e) kont)]


(specialized-prim "car")
 [(= e (apply (define-prim "car" _) (fixedarg [a]) ctx kont _))
  (store a (list-of-vals [_ ... ai _ ...]))
  -->
  (store (f-addr ctx e) ai)
  (ret (f-addr ctx e) kont)]

(specialized-prim "cdr")
 [(= e (apply (define-prim "cdr" _) (fixedarg [a]) ctx kont _))
  (store a (list-of-vals as))
   -->
  (store (f-addr ctx e) (list-of-vals as))
  (ret (f-addr ctx e) kont)]

(specialized-prim "list")
 [(= e (apply (define-prim "list" _) (fixedarg as) ctx kont _))
  -->
  (store (f-addr ctx e) (list-of-vals as))
  (ret (f-addr ctx e) kont)]

 [(= e (apply (define-prim "list" _) (vararg a) ctx kont _))
  (store a (list-of-vals as))
  -->
  (store (f-addr ctx e) (list-of-vals as))
  (ret (f-addr ctx e) kont)]

;; ASK ABOUT DO-TICK FOR PRIMS


;FIXED ARG
[(apply (clo (lambda (fixedparam [xs ...]) eb) ctxlam) (fixedarg [as ...]) ctxcall kont call)
 --> 
 (store (k-addr eb) kont)
 (= ctxtick {tick !(do-tick ctxcall call)})
 (do-fixed-prop-all ctxtick xs as)
 (eval eb ctxtick (k-addr eb))
 [(free y eb)
  -->
  (store (f-addr ctxtick y) {store (f-addr ctxlam y)})
  (store-flow (f-addr ctxtick y) (f-addr ctxlam y))
  ]]

[(apply (clo (lambda (varparam x) eb) ctxlam) (fixedarg [as ...]) ctxcall kont call)
 --> 
 (store (k-addr eb) kont)
 (= ctxtick {tick !(do-tick ctxcall call)})     
 (store (f-addr ctxtick x) (list-of-vals as))
 (eval eb ctxtick (k-addr eb))
 [(free y eb) 
  -->
  (store (f-addr ctxtick y) {store (f-addr ctxlam y)})
  (store-flow (f-addr ctxtick y) (f-addr ctxlam y))]]

;VARIADIC ARG
[(apply (clo (lambda (varparam x) eb) ctxlam) (vararg a) ctxcall kont call)
 --> 
 (store (k-addr eb) kont)
 (= ctxtick {tick !(do-tick ctxcall call)})
 (store-flow a (f-addr ctxtick x))
 ;(store (f-addr ctxtick x) {store a})
 (eval eb ctxtick (k-addr eb))
 [(free y eb)
  -->
  (store (f-addr ctxtick y) {store (f-addr ctxlam y)})
  (store-flow (f-addr ctxtick y) (f-addr ctxlam y))]]

[(apply (clo (lambda (fixedparam [xs ...]) eb) ctxlam) (vararg a) ctxcall kont call)
 (store a (list-of-vals as))
 -->
 (store (k-addr eb) kont)
 (= ctxtick {tick !(do-tick ctxcall call)})
 (do-var-prop-all ctxtick xs as)
 (eval eb ctxtick (k-addr eb))
 [(free y eb)
  -->
  (store-flow (f-addr ctxtick y) (f-addr ctxlam y))]]





;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;HELPER FUNCTIONS;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;
;DO-VIXED-PROP-ALL
[(do-fixed-prop-all ctxtick [x x-rest ...] [a a-rest ...])
 -->
 (do-fixed-prop-all ctxtick x-rest a-rest)
;  (store (f-addr ctxtick x) {store a})
 (store-flow a (f-addr ctxtick x))]


;DO-VAR-PROP-ALL
[(do-var-prop-all ctxtick [x x-rest ...] [a a-rest ...])
 -->
 (do-var-prop-all-h ctxtick [x x-rest ...] [a a-rest ...] [a a-rest ...])]

[(do-var-prop-all-h ctxtick [x x-rest ...] [a a-rest ...] a-old)
 -->
 (do-var-prop-all-h ctxtick [x x-rest ...] a-rest a-old)
 (store-flow a (f-addr ctxtick x))]


[(do-var-prop-all-h ctxtick [x x-rest ...] [] a-old)
 -->
 (do-var-prop-all-h ctxtick x-rest a-old a-old)]

;STORE-FLOW
[(store a v)
 (store-flow a a1)
 -->
 (store a1 v)]

;DETECTING ANSWER
(answer ?(ret (s-addr a) (halt)) {store (s-addr a)})
(answer ?(ret (f-addr _ a) (halt)) {store (f-addr _ a)})


;----------------------------------------------------------------------;
;;;;;;;;;;;;;;;;;;;;;;;;;;Inlinable Callsite Detection;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------;

; IS DEFINE-PRIM
; [(eval exp _ _)
; (= exp (app (ref func) _))
; (store (f-addr _ func) (define-prim dp_func _))
; (count store (f-addr _ func) (define-prim dp_func _) cnt)
;  -->
; (inlinable-call exp func dp_func cnt)]

; [(inlinable-call exp func dp_func cnt)
; -->
; (is-define-prim exp func dp_func {maximum inlinable-call exp func dp_func} {prim-count dp_func})]


; ; Combinator
; [(eval exp _ _)
; (= exp (app lam _))
; (= lam (lambda var body))
; (~ store (f-addr _ x) (define-prim x _))
; (free x lam)
;  -->
; (is-combinator exp lam x)]

;GENERATING CALL-SETS FOR FUNCTIONS
[(= e (app ef [eas ...]))
(apply vf _ _ _ e)
-->
(fun-at-call e vf)]

[(fun-at-call e vf)
(count fun-at-call e _ cnt)
-->
(fun-at-call-count e cnt)]

[(free var exp)
-->
(freevars exp var)]